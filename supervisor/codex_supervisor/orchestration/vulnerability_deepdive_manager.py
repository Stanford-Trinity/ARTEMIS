#!/usr/bin/env python3
import asyncio
import json
import logging
import os
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any

from ..prompts.vulnerability_deepdive_prompt import get_vulnerability_deepdive_prompt


class VulnerabilityDeepDiveManager:
    """Manages independent vulnerability deep-dive instances."""
    
    def __init__(self, session_dir: Path, codex_binary: str, task_config: dict, supervisor_model: str = "o3"):
        self.session_dir = session_dir
        self.codex_binary = codex_binary
        self.task_config = task_config
        self.supervisor_model = supervisor_model
        self.deepdive_instances = {}  # Track deep-dive instances separately
        
        # Create deep-dive workspace directory
        self.deepdive_dir = session_dir / "vulnerability_deepdives"
        self.deepdive_dir.mkdir(exist_ok=True)
        
    async def spawn_vulnerability_deepdive(self, vulnerability_details: str, source_instance_id: str) -> bool:
        """Spawn an independent deep-dive instance for a discovered vulnerability."""
        # Generate unique ID for this deep-dive
        deepdive_id = f"vuln_deepdive_{uuid.uuid4().hex[:8]}"
        workspace_name = f"deepdive_{source_instance_id}_{uuid.uuid4().hex[:6]}"
        
        # Create workspace and necessary subdirectories
        workspace_path = self.deepdive_dir / workspace_name
        workspace_path.mkdir(parents=True, exist_ok=True)
        
        # Create logs subdirectory for heartbeat files
        logs_dir = workspace_path / "logs"
        logs_dir.mkdir(exist_ok=True)
        
        # Create config file for autonomous mode: original supervisor config + vulnerability report
        config_data = dict(self.task_config)  # Copy original supervisor config
        config_data["vulnerability_report"] = vulnerability_details  # Add vulnerability report
        
        config_file = workspace_path / "deepdive_config.yaml"
        try:
            import yaml
            with open(config_file, 'w') as f:
                yaml.dump(config_data, f, default_flow_style=False)
        except ImportError:
            # Fallback to JSON if YAML not available
            config_file = workspace_path / "deepdive_config.json"
            with open(config_file, 'w') as f:
                json.dump(config_data, f, indent=2)
        
        # Build codex autonomous command (no duration flag - use default 30min, driver model can finish early)
        cmd = [
            self.codex_binary,
            "autonomous",
            "--config-file", str(config_file.resolve()),  # Use absolute path
            "--driver-model", self.supervisor_model,  # Use same model as supervisor
            "--logs-dir", str(workspace_path.resolve()),  # Use absolute path
            "--full-auto",  # Skip approvals and use workspace-write sandbox
            "--ignore-work-hours",  # Don't pause for work hours
            "--mode", "verification",  # Use verification specialist for deep-dives
        ]
        
        # Add agent model override if specified in environment
        subagent_model = os.getenv("SUBAGENT_MODEL") 
        if subagent_model:
            cmd.extend(["-c", f"model={subagent_model}"])
            logging.info(f"üîß Using SUBAGENT_MODEL override: {subagent_model}")
        else:
            logging.info("üîß No SUBAGENT_MODEL set, using default model config")
            
        # Force OpenRouter model provider to ensure it doesn't fall back to OpenAI
        cmd.extend(["-c", "model_provider=openrouter"])
        
        # Debug: Log full command after all overrides are added
        logging.info(f"üîß Full deep-dive command: {' '.join(cmd)}")
        logging.info(f"üîß Working directory: {workspace_path}")
        
        try:
            # Start the process with stdout/stderr redirected to files
            env = os.environ.copy()
            
            # Create log files for stdout/stderr
            stdout_file = workspace_path / "deepdive_stdout.log"
            stderr_file = workspace_path / "deepdive_stderr.log"
            
            with open(stdout_file, 'w') as stdout_f, open(stderr_file, 'w') as stderr_f:
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=stdout_f,
                    stderr=stderr_f,
                    cwd=workspace_path,
                    env=env,
                    preexec_fn=os.setsid if hasattr(os, 'setsid') else None
                )
            
            # Track the deep-dive instance
            self.deepdive_instances[deepdive_id] = {
                "process": process,
                "workspace_name": workspace_name,
                "workspace_path": workspace_path,
                "source_instance": source_instance_id,
                "vulnerability": vulnerability_details[:100] + "..." if len(vulnerability_details) > 100 else vulnerability_details,
                "started_at": datetime.now(timezone.utc).isoformat(),
                "status": "running"
            }
            
            logging.info(f"üîç Spawned vulnerability deep-dive {deepdive_id} for source instance {source_instance_id}")
            
            # Start monitoring task (fire and forget)
            asyncio.create_task(self._monitor_deepdive(deepdive_id))
            
            return True
            
        except Exception as e:
            logging.error(f"‚ùå Failed to spawn vulnerability deep-dive: {e}")
            return False
    
    async def _monitor_deepdive(self, deepdive_id: str):
        """Monitor a deep-dive instance until completion."""
        instance = self.deepdive_instances[deepdive_id]
        process = instance["process"]
        
        try:
            # Wait for process completion (no timeout - let it finish naturally)
            await process.wait()
            
            if process.returncode == 0:
                instance["status"] = "completed"
                logging.info(f"‚úÖ Vulnerability deep-dive {deepdive_id} completed successfully")
            else:
                instance["status"] = "failed"
                logging.error(f"‚ùå Vulnerability deep-dive {deepdive_id} failed with exit code {process.returncode}")
                
                # Read stderr from file for debugging
                stderr_file = instance["workspace_path"] / "deepdive_stderr.log"
                if stderr_file.exists():
                    try:
                        with open(stderr_file, 'r') as f:
                            stderr_content = f.read().strip()
                            if stderr_content:
                                logging.error(f"‚ùå Deep-dive stderr: {stderr_content}")
                    except Exception as e:
                        logging.error(f"Failed to read stderr file: {e}")
                
        except Exception as e:
            logging.error(f"üí• Error monitoring deep-dive {deepdive_id}: {e}")
            instance["status"] = "error"