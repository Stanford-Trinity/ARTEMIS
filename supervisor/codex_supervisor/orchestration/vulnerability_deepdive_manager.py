#!/usr/bin/env python3
import asyncio
import json
import logging
import os
import uuid
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, Any

from ..prompts.vulnerability_deepdive_prompt import get_vulnerability_deepdive_prompt


class VulnerabilityDeepDiveManager:
    """Manages independent vulnerability deep-dive instances."""
    
    def __init__(self, session_dir: Path, codex_binary: str, task_config: dict, supervisor_model: str = "o3"):
        self.session_dir = session_dir
        self.codex_binary = codex_binary
        self.task_config = task_config
        self.supervisor_model = supervisor_model
        self.deepdive_instances = {}  # Track deep-dive instances separately
        
        # Create deep-dive workspace directory
        self.deepdive_dir = session_dir / "vulnerability_deepdives"
        self.deepdive_dir.mkdir(exist_ok=True)
        
    async def spawn_vulnerability_deepdive(self, vulnerability_details: str, source_instance_id: str) -> bool:
        """Spawn an independent deep-dive instance for a discovered vulnerability."""
        # Generate unique ID for this deep-dive
        deepdive_id = f"vuln_deepdive_{uuid.uuid4().hex[:8]}"
        workspace_name = f"deepdive_{source_instance_id}_{uuid.uuid4().hex[:6]}"
        
        # Create workspace
        workspace_path = self.deepdive_dir / workspace_name
        workspace_path.mkdir(parents=True, exist_ok=True)
        
        # Create config file for autonomous mode: original supervisor config + vulnerability report
        config_data = dict(self.task_config)  # Copy original supervisor config
        config_data["vulnerability_report"] = vulnerability_details  # Add vulnerability report
        
        config_file = workspace_path / "deepdive_config.yaml"
        try:
            import yaml
            with open(config_file, 'w') as f:
                yaml.dump(config_data, f, default_flow_style=False)
        except ImportError:
            # Fallback to JSON if YAML not available
            config_file = workspace_path / "deepdive_config.json"
            with open(config_file, 'w') as f:
                json.dump(config_data, f, indent=2)
        
        # Build codex autonomous command (no duration flag - use default 30min, driver model can finish early)
        cmd = [
            self.codex_binary,
            "autonomous",
            "--config-file", str(config_file.resolve()),  # Use absolute path
            "--driver-model", "o3",  # Use same model as supervisor
            "--logs-dir", str(workspace_path.resolve()),  # Use absolute path
            "--full-auto",  # Skip approvals and use workspace-write sandbox
            "--ignore-work-hours",  # Don't pause for work hours
            "--mode", "verification",  # Use verification specialist for deep-dives
        ]
        
        try:
            # Start the process
            env = os.environ.copy()
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=workspace_path,
                env=env,
                preexec_fn=os.setsid if hasattr(os, 'setsid') else None
            )
            
            # Track the deep-dive instance
            self.deepdive_instances[deepdive_id] = {
                "process": process,
                "workspace_name": workspace_name,
                "source_instance": source_instance_id,
                "vulnerability": vulnerability_details[:100] + "..." if len(vulnerability_details) > 100 else vulnerability_details,
                "started_at": datetime.now(timezone.utc).isoformat(),
                "status": "running"
            }
            
            logging.info(f"ğŸ” Spawned vulnerability deep-dive {deepdive_id} for source instance {source_instance_id}")
            
            # Start monitoring task (fire and forget)
            asyncio.create_task(self._monitor_deepdive(deepdive_id))
            
            return True
            
        except Exception as e:
            logging.error(f"âŒ Failed to spawn vulnerability deep-dive: {e}")
            return False
    
    async def _monitor_deepdive(self, deepdive_id: str):
        """Monitor a deep-dive instance until completion."""
        instance = self.deepdive_instances[deepdive_id]
        process = instance["process"]
        
        try:
            # Wait for process completion (no timeout - let it finish naturally)
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                instance["status"] = "completed"
                logging.info(f"âœ… Vulnerability deep-dive {deepdive_id} completed successfully")
            else:
                instance["status"] = "failed"
                logging.error(f"âŒ Vulnerability deep-dive {deepdive_id} failed with exit code {process.returncode}")
                if stderr:
                    logging.error(f"âŒ Deep-dive stderr: {stderr.decode()}")
                if stdout:
                    logging.info(f"ğŸ“„ Deep-dive stdout: {stdout.decode()}")
                
        except Exception as e:
            logging.error(f"ğŸ’¥ Error monitoring deep-dive {deepdive_id}: {e}")
            instance["status"] = "error"